<!doctype html><html lang=zh-cn><head><title>使用 Kotlin 语言实现一个快速排序算法 ::
星野玲的博客</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="今天小玲来教大家用 Kotlin 语言实现一个快速排序算法。将一个元素是 Double 类型的 List 从小到大排序。整个函数代码仅仅只有 11 行。快速排序算法的原理小玲就不再赘述"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.bling.moe/post/12/><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://blog.bling.moe/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://blog.bling.moe/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://blog.bling.moe/img/favicon.png><link href=/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="使用 Kotlin 语言实现一个快速排序算法"><meta name=twitter:description content="今天小玲来教大家用 Kotlin 语言实现一个快速排序算法。将一个元素是 `Double` 类型的 `List` 从小到大排序。整个函数代码仅仅只有 11 行。"><meta property="og:title" content="使用 Kotlin 语言实现一个快速排序算法"><meta property="og:description" content="今天小玲来教大家用 Kotlin 语言实现一个快速排序算法。将一个元素是 `Double` 类型的 `List` 从小到大排序。整个函数代码仅仅只有 11 行。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.bling.moe/post/12/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-01-08T00:00:00+08:00"><meta property="article:modified_time" content="2021-11-18T14:08:07+08:00"><meta property="og:site_name" content="星野玲的博客"></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>星野玲的博客</span>
<span class=logo__cursor></span></a>
<span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/index.xml>RSS</a></li><li><a href=/about/>关于</a></li><li><a href=/links/>友链</a></li><ul class=menu__sub-inner><li class=menu__sub-inner-more-trigger>查看更多
<span class=menu__sub-inner-more-trigger-icon><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span></li><ul class="menu__sub-inner-more hidden"><li><a href=https://digital-garden.bling.moe>数字花园</a></li></ul></ul></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/index.xml>RSS</a></li><li><a href=/about/>关于</a></li><li><a href=/links/>友链</a></li><li><a href=https://digital-garden.bling.moe>数字花园</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><article class=post><h1 class=post-title>使用 Kotlin 语言实现一个快速排序算法</h1><div class=post-meta><time class=post-date>2023-01-08</time>
<span class=post-author>— 作者： 星野玲</span></div><span class=post-tags><a href=https://blog.bling.moe/tags/kotlin/>#Kotlin</a>&nbsp;
<a href=https://blog.bling.moe/tags/%E7%AE%97%E6%B3%95/>#算法</a>&nbsp;</span><div class=post-content><p>今天小玲来教大家用 Kotlin 语言实现一个快速排序算法。将一个元素是 <code>Double</code> 类型的 <code>List</code> 从小到大排序。整个函数代码仅仅只有 11 行。快速排序算法的原理小玲就不再赘述了，这里小玲只讲实现。</p><h2 id=安装-intellij-idea>安装 Intellij IDEA
<a href=#%e5%ae%89%e8%a3%85-intellij-idea class=h-anchor aria-hidden=true>#</a></h2><p>咱们要采用 Intellij IDEA 这款 IDE 来编写 Kotlin 程序。如果你已经有了可以跳过。</p><p>因为目前小玲还在使用 Windows，所以给出的安装命令都是 Windows 的。如果你使用 macOS、Linux，还请自己学习如何安装。</p><p>这是使用 <a href=https://blog.bling.moe/post/11/>Scoop</a> 安装 Intellij IDEA 的命令。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>scoop bucket add extras
</span></span><span style=display:flex><span>scoop install extras/idea
</span></span></code></pre></div><p>开发 Kotlin Native 程序还是需要一个 JDK 的。如果你没有 JDK，可以安装一个。小玲就用 graalvm-17 这个 JDK 好了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>scoop bucket add java
</span></span><span style=display:flex><span>scoop install java/graalvm-jdk17
</span></span></code></pre></div><h2 id=创建项目>创建项目
<a href=#%e5%88%9b%e5%bb%ba%e9%a1%b9%e7%9b%ae class=h-anchor aria-hidden=true>#</a></h2><p>因为咱们只使用 Kotlin 语言，所以要创建一个 Kotlin Native 项目。Kotlin Native 项目要在 Kotlin Multiplatform 里面创建。</p><figure class=center><img src=Snipaste_2023-01-07_23-44-45.png></figure><p>这一步咱们不需要修改，直接点击 <code>Finish</code> 即可。</p><figure class=center><img src=Snipaste_2023-01-07_23-44-52.png></figure><h2 id=开始编写>开始编写
<a href=#%e5%bc%80%e5%a7%8b%e7%bc%96%e5%86%99 class=h-anchor aria-hidden=true>#</a></h2><p>创建完成后，<code>src/nativeMain/kotlin/Main.kt</code> 文件默认如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    println(<span style=color:#e6db74>&#34;Hello, Kotlin/Native!&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>咱们在 <code>main()</code> 函数的下面写上快速排序函数的大概框架。首先它的函数名为 <code>quickSort</code>，接收一个类型为 <code>List&lt;Double></code>、名称为 <code>list</code> 的形参，返回值类型为 <code>List&lt;Double></code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>quickSort</span>(list: List&lt;Double&gt;): List&lt;Double&gt; {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>咱们采用递归加分治的方法来写。因为是递归了，所以一定要有一个递归出口，否则会无限循环。</p><p>这里咱们就判断形参 <code>list</code> 有多少个元素，如果元素个数小于或等于 1 了，就直接返回这个形参。这也适用于用 <code>quickSort()</code> 函数处理只有一个元素的 <code>List</code> 的情况。因为只有 1 个元素了，所以就没有排序的必要了，直接返回它本身就好。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>quickSort</span>(list: List&lt;Double&gt;): List&lt;Double&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>if</span> (list.size <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        list
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>if</code> 语句的 <code>else</code> 块里就要写递归和分治的代码了。</p><p>咱们需要在这个 <code>List</code> 里先找一个基准点。把 <code>List</code> 里除了基准点所在的元素的剩余所有元素划分为两个部分。</p><p>一个部分里的所有元素都比基准点所在的元素小，这个部分咱们称作 <code>leftList</code>，意思是从小到大排序的话，这个部分都会在基准点左边。</p><p>另一个部分里的所有元素都比基准点所在的元素大或等于基准点所在的元素，这个部分咱们称作 <code>rightList</code>，意思是从小到大排序的话，这个部分都会在基准点的右边。</p><p>然后对 <code>leftList</code> 和 <code>rightList</code> 递归调用这个函数本身，它会不断地划分 <code>leftList</code> 的 <code>leftList</code>、<code>leftList</code> 的 <code>rightList</code>、<code>rightList</code> 的 <code>leftList</code>、<code>rightList</code> 的 <code>rightList</code>，直到不可划分为止。再按 <code>leftList</code>、基准点、<code>rightList</code> 的顺序合并 List，把合并的结果返回给上一层，直到不可合并为止。最后合并这个结果就是整个 <code>list</code> 形参排序之后的结果了。</p><p>下面是代码实现，现在咱们就写完 <code>quickSort()</code> 函数了。现在这个函数除了注释就只有 11 行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>quickSort</span>(list: List&lt;Double&gt;): List&lt;Double&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>if</span> (list.size <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        list
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 定义基准点位于 list 中的索引
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>val</span> pivotIndex = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将 list 中除了基准点的剩余元素找出来，并存放在 listWithoutPivot 变量里。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>val</span> listWithoutPivot = list.filterIndexed{<span style=color:#66d9ef>it</span>, _ <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>it</span> <span style=color:#f92672>!=</span> pivotIndex}
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将 listWithoutPivot 里小于基准点的元素找出来，并存放在 leftList 变量里。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>val</span> leftList = listWithoutPivot.filter { <span style=color:#66d9ef>it</span> &lt; list[pivotIndex] }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将 listWithoutPivot 里大于或等于基准点的元素找出来，并存放在 rightList 变量里。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>val</span> rightList = listWithoutPivot.filter { <span style=color:#66d9ef>it</span> <span style=color:#f92672>&gt;=</span> list[pivotIndex] }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 递归调用和合并
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        listOf(quickSort(leftList), listOf(list[pivotIndex]), quickSort(rightList)).flatten()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>至于将哪个元素作为基准点其实都可以，它不会影响最终排序的结果。这里咱们就将 <code>list</code> 里的第 1 个元素作为基准点，你也可以将 <code>list</code> 的最后一个元素作为基准点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> pivotIndex = list.size - <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>也可以将中间那个元素作为基准点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> pivotIndex = <span style=color:#66d9ef>if</span> (list.size % <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) list.size / <span style=color:#ae81ff>2</span> - <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>else</span> list.size / <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>不过要注意索引不要溢出，比如 <code>list</code> 里只有 2 个元素，取第 3 个元素作为基准点就溢出了。</p><h2 id=测试>测试
<a href=#%e6%b5%8b%e8%af%95 class=h-anchor aria-hidden=true>#</a></h2><p>写完了以后，咱们来测试一下吧。把 <code>main()</code> 函数修改一下。生成 10 个小数点后有 1 位的小数，再把它们添加到一个 <code>List</code> 里，然后对这个 <code>List</code> 进行排序，观察排序的结果。</p><p>下面是最终的 <code>Main.kt</code> 文件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>import</span> kotlin.math.roundToInt
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> kotlin.random.Random
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> kotlin.system.getTimeMillis
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> list = mutableListOf&lt;Double&gt;()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> random = Random(getTimeMillis())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0.</span>.<span style=color:#ae81ff>9</span>) {
</span></span><span style=display:flex><span>        list.add((random.nextDouble(<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>100.0</span>) * <span style=color:#ae81ff>10</span>).roundToInt() / <span style=color:#ae81ff>10.0</span> )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println(<span style=color:#e6db74>&#34;Original list is </span><span style=color:#e6db74>$list</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    println(<span style=color:#e6db74>&#34;Sorted list from quickSort is </span><span style=color:#e6db74>${quickSort(list)}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>quickSort</span>(list: List&lt;Double&gt;): List&lt;Double&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>if</span> (list.size <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        list
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>val</span> pivotIndex = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>val</span> listWithoutPivot = list.filterIndexed{<span style=color:#66d9ef>it</span>, _ <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>it</span> <span style=color:#f92672>!=</span> pivotIndex}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>val</span> leftList = listWithoutPivot.filter { <span style=color:#66d9ef>it</span> &lt; list[pivotIndex] }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>val</span> rightList = listWithoutPivot.filter { <span style=color:#66d9ef>it</span> <span style=color:#f92672>&gt;=</span> list[pivotIndex] }
</span></span><span style=display:flex><span>        listOf(quickSort(leftList), listOf(list[pivotIndex]), quickSort(rightList)).flatten()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行结果，很完美地从小到大排序了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Original list is [64.8, 74.6, 96.7, 57.1, 58.3, 59.4, 18.8, 60.2, 4.9, 17.4]
</span></span><span style=display:flex><span>Sorted list from quickSort is [4.9, 17.4, 18.8, 57.1, 58.3, 59.4, 60.2, 64.8, 74.6, 96.7]
</span></span></code></pre></div><h2 id=结尾>结尾
<a href=#%e7%bb%93%e5%b0%be class=h-anchor aria-hidden=true>#</a></h2><p>好了，这篇文章就到这里。这是小玲首次写编程相关的文章。可能会有一些错误，如果有，还请指正，谢谢！</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>阅读其它文章</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://blog.bling.moe/post/13/><span class=button__icon>←</span>
<span class=button__text>使用 Kotlin 语言实现一个归并排序算法</span></a></span>
<span class="button next"><a href=https://blog.bling.moe/post/11/><span class=button__text>Windows 包管理器——Scoop 上手教程</span>
<span class=button__icon>→</span></a></span></div></div><script src=https://giscus.app/client.js data-repo=HoshinoRei/blog data-repo-id=R_kgDOGZbNzw data-category=General data-category-id=DIC_kwDOGZbNz84CPgAu data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>星野玲的博客</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span><a href=https://github.com/panr/hugo-theme-hello-friend target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-E6TTBX28QL"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-E6TTBX28QL",{anonymize_ip:!1})}</script></body></html>